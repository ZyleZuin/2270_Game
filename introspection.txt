Introspection – 2270 Blackjack EditionInitial Ideas: Upon forming our group we immediately ruled out games that take boards or grids due to the difficulty of expressing the game space to the user.  We instead felt that a card game would be best as generally you have a limited hand and can be easily understood using Char objects.Pivots: While, we decided on a card game we bounced around from various types at first.  Some of the obvious ones like war were too simple.  It didn’t give us an opportunity to use any real structures or create an AI.  We also, felt that a single person game like solitaire would be difficult to textually implement and again lacked opportunity for a real opponent.  Our final decision came down to casino games as they had a deal and other players, didn’t involve many cards at one time, and had fairly simple decisions to make.  You usually hit, stayed, bet, raised, folded.  We knew that if we choose a poker game we’d likely get bogged down trying to create a decent AI for various players.  Given our timeline we felt blackjack would be a suitable game with different states, winning conditions, ability to build an AI, and easy textual gameplay. Data Structures: All three members of our group preferred object oriented programming and thus we began by defining what classes we would need.  We ended up with a shoe class that held the deck of cards.  It used an integer vector to give cards/values out to players.  We then had a player class and a table class to drive the play.  We had a function that would shuffle the elements randomly in the stack of cards as well as push/pop from it.  We also used user input to drive the state of the game from in progress, to new round, to game over.  We could have used any number of different structures for the cards including deques, linked lists, or a pq, but we felt the dynamic aspect of the vector class was best suited for the game.Hardest Aspect:  Certainly the hardest aspect was team coding.  We were a group of three that quickly came together in the lab and started hacking.  We began with creating a github repo for our work.  We created the basic blank files and then all sat down and wrote the header together.  We thought that by having a clearly outlined header would allow us to work on separate parts of the cpp file without breaking too much.  After fighting git merging a little, and changing some of our function return types and arguments, we were able to all take on a separate class’s (we had three classes) functions and bring them together.  Within 30 minutes of merging we were able to compile and run and begin squishing bugs.  While, we had good luck in the end, this was certainly the most complicated aspect of the project and was solved by good early planning.